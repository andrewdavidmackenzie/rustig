#![allow(clippy::type_complexity)]
// (C) COPYRIGHT 2018 TECHNOLUTION BV, GOUDA NL

// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

mod lea_dynamic_calls;
mod static_calls;
mod x86_cg_builder;

use crate::CallGraph;
use crate::Context;
use crate::Invocation;
use crate::Location;
use crate::Procedure;

use std::cell::RefCell;
use std::collections::HashMap;
use std::rc::Rc;
use std::string::String;

use fallible_iterator::FallibleIterator;

use crate::errors::*;

use gimli::{AttributeValue, UnitHeader};
use gimli::DW_AT_comp_dir;
use gimli::DW_AT_high_pc;
use gimli::DW_AT_inline;
use gimli::DW_AT_language;
use gimli::DW_AT_low_pc;
use gimli::DW_TAG_compile_unit;
use gimli::DebuggingInformationEntry;
use gimli::EndianSlice;
use gimli::EntriesCursor;
use gimli::LittleEndian;

use object::Object;
use object::ObjectSection;

use petgraph::stable_graph::{NodeIndex, StableGraph};

use crate::crate_utils;
use crate::dwarf_utils;
use std::marker::PhantomData;
use crate::callgraph::x86_cg_builder::X86CallGraphBuilder;

pub struct CompilationInfo<'a> {
    compilation_dirs: &'a [&'a str],
    rust_version: &'a str,
}

pub trait InvocationFinder<P, I: Default, F: Default> {
    fn find_invocations(
        &self,
        graph: &mut StableGraph<Rc<RefCell<Procedure<P>>>, Rc<RefCell<Invocation<I, F>>>>,
        proc_index: &mut HashMap<u64, NodeIndex>,
        call_index: &mut HashMap<u64, NodeIndex>,
        ctx: &Context,
        compilation_info: CompilationInfo,
    );
}

/// Trait marking objects that are able to build a call graph from a parsed binary
pub trait CallGraphBuilder<PMetadata: Default, IMetadata: Default, FMetadata> {
    fn build_call_graph(&self, ctx: &Context) -> CallGraph<PMetadata, IMetadata, FMetadata>;
}

/// Struct abstracting the machine code for a procedure.
struct MachineCode<'a> {
    /// Function address in binary
    address: u64,
    /// Instruction bytes
    raw_instr: &'a [u8],
}

/// Metadata about the location af an assembly procedure.
struct LocationInfo {
    /// Address of the procedure in the executable
    address: u64,
    /// Size in bytes of the procedure
    size: u64,
}

/// Metadata about the different names of a procedure
struct NameInfo {
    /// Name as defined in the source code (`DW_AT_name`).
    name: String,
    /// Mangled linkage name as generated by the compiler
    linkage_name: String,
    /// Demangled linkage name
    linkage_name_demangled: String,
}

/// If the current compile unit was compiled as Rust code, this function returns all procedures in that compile unit.
///
/// However:
/// - If a function was inlined, it will not be returned
/// - If the cursor was not at a compile unit entry, it will panic
fn iterate_compilation_unit<PM: Default>(
    unit: UnitHeader<EndianSlice<LittleEndian>>,
    entries: &mut EntriesCursor<EndianSlice<LittleEndian>>,
    ctx: &Context,
    compilation_unit_dirs: &[&str],
) -> Vec<Procedure<PM>> {
    let cu = {
        let cu_entry = entries
            .current()
            .expect("Cursor not advanced to compilation unit entry.");
        assert_eq!(
            cu_entry.tag(),
            DW_TAG_compile_unit,
            "Current cursor entry is not a compilation unit"
        );

        // If the language of the current compile unit is not Rust, skip it
        match cu_entry
            .attr(DW_AT_language)
            .map(|att_opt| att_opt.map(|att| att.value()))
        {
            Ok(Some(AttributeValue::Language(gimli::DW_LANG_Rust))) => (),
            _ => return vec![],
        }
        cu_entry.clone()
    };

    parse_compilation_unit_subprograms(&unit, entries, ctx, compilation_unit_dirs, &cu)
}

/// Function creating `Procedure`s for all nodes in a DWARF compilation unit.
fn parse_compilation_unit_subprograms<PM: Default>(
    unit: &UnitHeader<EndianSlice<LittleEndian>, usize>,
    entries: &mut EntriesCursor<EndianSlice<LittleEndian>>,
    ctx: &Context,
    compilation_unit_dirs: &[&str],
    cu: &DebuggingInformationEntry<EndianSlice<LittleEndian>, usize>,
) -> Vec<Procedure<PM>> {
    // Iterate over entries
    // AZ: I feel like we should try to optimize this, by doing next_sibling when an DW_TAG_subprogram was hit
    let mut nodes: Vec<Procedure<PM>> = vec![];
    while let Some((_, entry)) = entries.next_dfs().unwrap() {
        // If we find an entry for a function, print it.
        if entry.tag() == gimli::DW_TAG_subprogram {
            // If function is declared inline, skip it
            match entry
                .attr(DW_AT_inline)
                .map(|att_opt| att_opt.map(|att| att.value()))
            {
                Ok(Some(AttributeValue::Inline(gimli::DW_INL_declared_inlined)))
                | Ok(Some(AttributeValue::Inline(gimli::DW_INL_inlined))) => continue,
                _ => (),
            }

            let NameInfo { linkage_name, .. } = fetch_function_names(unit, ctx, entry);
            let LocationInfo {
                address: start_address,
                size,
            } = fetch_function_location_info(entry, &linkage_name);

            // Skip functions with low_pc = 0
            if start_address == 0 {
                continue;
            }

            let prc = get_procedure(
                unit,
                ctx,
                compilation_unit_dirs,
                cu,
                entry,
                start_address,
                size,
            );

            nodes.push(prc)
        }
    }
    nodes
}

/// Function that builds a `Procedure` for a DWARF DW_AT_subprogram entry(`entry`)
fn get_procedure<PM: Default>(
    unit: &UnitHeader<EndianSlice<LittleEndian>, usize>,
    ctx: &Context,
    compilation_unit_dirs: &[&str],
    cu: &DebuggingInformationEntry<EndianSlice<LittleEndian>, usize>,
    entry: &DebuggingInformationEntry<EndianSlice<LittleEndian>, usize>,
    start_address: u64,
    size: u64,
) -> Procedure<PM> {
    let NameInfo {
        name,
        linkage_name,
        linkage_name_demangled,
    } = fetch_function_names(unit, ctx, entry);
    let MachineCode {
        address: code_address,
        raw_instr: proc_instr_raw,
    } = fetch_procedure_machine_code(ctx, start_address, size);

    let lookup_result = ctx.loader.find_frames(start_address).unwrap();

    let location = lookup_result
        .filter_map(|frame| Ok(frame.location))
        .last()
        .unwrap()
        .map(Location::from);

    let defining_crate = {
        let defining_file = location.as_ref().map(|loc| &loc.file[..]);
        crate_utils::get_crate_details(
            code_address,
            defining_file,
            cu,
            ctx,
            compilation_unit_dirs,
        )
    };

    Procedure {
        name,
        linkage_name,
        linkage_name_demangled,
        defining_crate,
        start_address,
        size,
        location,
        attributes: PM::default(),
        disassembly: ctx.capstone
            .disasm_all(proc_instr_raw, start_address)
            .expect("Failed to disassemble procedure"),
    }
}

/// Returns the machine code for a procedure at `start_address`.
fn fetch_procedure_machine_code<'a>(
    ctx: &'a Context,
    start_address: u64,
    size: u64,
) -> MachineCode<'a> {
    let code_section = ctx.elf
        .sections()
        .find(|x| x.name() == Some(".text"))
        .expect("No '.text' section found");
    let code_address = code_section.address();
    let code_data = code_section.data();
    let proc_sec_offset = start_address - code_address;
    let proc_sec_end = (proc_sec_offset + size) as usize;
    let proc_instr_raw = &code_data[(proc_sec_offset as usize)..proc_sec_end];
    MachineCode {
        address: code_address,
        raw_instr: proc_instr_raw,
    }
}

fn fetch_function_location_info(
    entry: &DebuggingInformationEntry<EndianSlice<LittleEndian>, usize>,
    linkage_name: &str,
) -> LocationInfo {
    let start_address =
        dwarf_utils::get_attr_addr_value(entry, DW_AT_low_pc).unwrap_or_else(|| {
            panic!(
                "No DW_AT_low_pc attribute found for function {}",
                linkage_name
            )
        });
    let size = dwarf_utils::get_attr_u64_value(entry, DW_AT_high_pc).unwrap_or_else(|| {
        panic!(
            "No DW_AT_high_pc attribute found for function {}",
            linkage_name
        )
    });
    LocationInfo {
        address: start_address,
        size,
    }
}

/// Function returning the names iof the procedure references in `entry`.
fn fetch_function_names(
    unit: &UnitHeader<EndianSlice<LittleEndian>, usize>,
    ctx: &Context,
    entry: &DebuggingInformationEntry<EndianSlice<LittleEndian>>,
) -> NameInfo {
    // Fetch function details
    let name = dwarf_utils::get_attr_str_with_origin_traversal(
        unit,
        entry,
        gimli::DW_AT_name,
        &unit.abbreviations(&ctx.dwarf_abbrev).unwrap(),
        &ctx.dwarf_strings,
    );
    let linkage_name = dwarf_utils::get_attr_str_with_origin_traversal(
        unit,
        entry,
        gimli::DW_AT_linkage_name,
        &unit.abbreviations(&ctx.dwarf_abbrev).unwrap(),
        &ctx.dwarf_strings,
    );
    let linkage_name_demangled = dwarf_utils::demangle_symbol(&linkage_name);
    NameInfo {
        name,
        linkage_name,
        linkage_name_demangled,
    }
}

/// Function returning all compilation unit directories used to assembly the binary.
/// These compilation unit dirs are used at a later stage to determine crate names.
///
/// The returned list is guaranteed not to contain duplicates, and is sorted descending lexicographically.
/// That enables easy determination of the crate name in `get_crate_details`.
fn get_compilation_unit_directories<'a>(ctx: &'a Context) -> Vec<&'a str> {
    let mut compilation_unit_dirs = vec![];

    // Iterate over all compilation units to get a list of all compilation directories.
    ctx.dwarf_info.units().iterator().for_each(|unit_header| {
        let unit_header = unit_header.unwrap();
        let abbrevs = unit_header.abbreviations(&ctx.dwarf_abbrev).unwrap();
        let mut entries = unit_header.entries(&abbrevs);

        let (_, entry) = entries
            .next_dfs()
            .expect("First compilation unit could not be selected")
            .unwrap();

        // Retrieve the name of the compilation unit
        if entry.tag() == DW_TAG_compile_unit {
            let cu_name =
                dwarf_utils::get_attr_string_buf(entry, DW_AT_comp_dir, &ctx.dwarf_strings);
            compilation_unit_dirs.push(cu_name.unwrap().to_string().unwrap());
        }
    });

    // Sort and remove duplicates to improve runtime when using for_each
    compilation_unit_dirs.sort();
    compilation_unit_dirs.dedup();

    // To ensure that longest match is found first, we should reverse after sorting.
    compilation_unit_dirs.reverse();
    compilation_unit_dirs
}

/// Parses all procedures in a DWARF compilation unit.
fn get_procedures_for_compilation_unit<PMetadata: Default>(
    ctx: &Context,
    compilation_unit_dirs: &[&str],
    unit_header: UnitHeader<EndianSlice<LittleEndian>, usize>,
) -> Vec<Procedure<PMetadata>> {
    // Find entries in cu
    let abbrevs = unit_header.abbreviations(&ctx.dwarf_abbrev).unwrap();
    let mut entries = unit_header.entries(&abbrevs);
    entries
        .next_dfs()
        .expect("First compilation unit could not be selected");
    // Let cursor select first unit
    // Return found
    let res: Vec<Procedure<PMetadata>> =
        iterate_compilation_unit(unit_header, &mut entries, ctx, compilation_unit_dirs);
    res
}

/// Returns a call graph builder based on the passed `CallGraphOptions`.
/// If the binary was compiled for x86 or x86_64, a builder will be returned.
/// In other cases, the procedure will return an error.
pub fn get_call_graph_builder<
    PMetadata: Default + 'static,
    IMetadata: Default + 'static,
    FMetadata: Default + 'static,
>(
    ctx: &Context,
) -> Result<Box<dyn CallGraphBuilder<PMetadata, IMetadata, FMetadata>>> {
    match ctx.elf.machine() {
        object::Machine::X86 | object::Machine::X86_64 => Ok(Box::new(X86CallGraphBuilder {
            invocation_finders: vec![
                Box::new(static_calls::StaticCallInvocationFinder),
                Box::new(lea_dynamic_calls::LEABasedDynamicInvocationFinder {
                    phantom: PhantomData,
                }),
            ],
        })),
        object::Machine::Arm | object::Machine::Arm64 => {
            Err(ErrorKind::NotSupported("the ARM Instruction Set".to_string()).into())
        }
        object::Machine::Other => {
            Err(ErrorKind::NotSupported("an unknown instruction set".to_string()).into())
        }
    }
}

#[cfg(test)]
mod test {
    use super::*;

    use gimli::*;

    use Context;
    use crate::InvocationType;

    use super::lea_dynamic_calls::LEABasedDynamicInvocationFinder;
    use super::static_calls::StaticCallInvocationFinder;

    use object::Object;
    use crate::parse::get_parser;

    // Two workspaces could have similar names, for example: test_subjects and test_subjects_lib
    // The program should still distinguish between these two
    #[test]
    fn test_similar_workspaces() {
        let file_content = &test_common::load_test_binary_as_bytes(
            "lib_calls",
            &test_common::TestSubjectType::Debug,
        ).unwrap();

        let parser = get_parser().expect("Could not parse test file contents");
        let context = parser.parse(file_content);
        let call_graph: CallGraph<(), (), ()> = X86CallGraphBuilder {
            invocation_finders: vec![
                Box::new(StaticCallInvocationFinder),
                Box::new(LEABasedDynamicInvocationFinder::default()),
            ],
        }.build_call_graph(&context);

        let test_subject_count = call_graph
            .graph
            .node_indices()
            .map(|node_index| call_graph.graph[node_index].borrow())
            .filter(|node| node.defining_crate.name == "test_subjects")
            .count();

        let test_subject_lib_count = call_graph
            .graph
            .node_indices()
            .map(|node_index| call_graph.graph[node_index].borrow())
            .filter(|node| node.defining_crate.name == "test_subjects_lib")
            .count();

        assert_eq!(test_subject_count, 11);
        assert_eq!(test_subject_lib_count, 51);
    }

    /// Test if a call graph can be created from the example binary
    #[test]
    pub fn test_call_graph_creation() {
        let file_content = &test_common::load_test_binary_as_bytes(
            "threads",
            &test_common::TestSubjectType::DebugStableRustc,
        ).unwrap();

        let parser = get_parser().expect("Could not parse test file contents");
        let context = parser.parse(file_content);
        let call_graph: CallGraph<(), (), ()> = X86CallGraphBuilder {
            invocation_finders: vec![
                Box::new(StaticCallInvocationFinder),
                Box::new(LEABasedDynamicInvocationFinder::default()),
            ],
        }.build_call_graph(&context);

        let procedure_address = context
            .elf
            .symbols()
            .find(|x| x.name() == Some("_ZN7threads4main17h4b75fb668cdcdf48E"))
            .expect("Symbol for main function could not be found")
            .address();

        // Assert function CallTypes::main is where we expect it to be
        assert!(call_graph.proc_index.contains_key(&procedure_address));

        let rc_procedure = call_graph
            .get_procedure(procedure_address)
            .expect("Error getting procedure for address.");

        let procedure = rc_procedure.as_ref().borrow();

        assert_eq!(call_graph.graph.node_count(), 713);
        assert_eq!(call_graph.graph.edge_count(), 1511);
        assert_eq!(
            call_graph
                .graph
                .edge_indices()
                .filter(|x| call_graph.graph[*x].borrow().invocation_type == InvocationType::Direct)
                .count(),
            1203
        );
        assert_eq!(
            call_graph
                .graph
                .edge_indices()
                .filter(|x| call_graph.graph[*x].borrow().invocation_type == InvocationType::VTable)
                .count(),
            146
        );
        assert_eq!(
            call_graph
                .graph
                .edge_indices()
                .filter(|x| call_graph.graph[*x].borrow().invocation_type
                    == InvocationType::ProcedureReference)
                .count(),
            103
        );
        assert_eq!(call_graph.proc_index.len(), 713);
        assert_eq!(call_graph.call_index.len(), 5704);

        assert_eq!(procedure.name, "main");
        assert_eq!(
            procedure.linkage_name,
            "_ZN7threads4main17h4b75fb668cdcdf48E"
        );
        assert_eq!(procedure.linkage_name_demangled, "threads::main");

        assert_eq!(procedure.defining_crate.name, "test_subjects_stable_rustc");
        assert_eq!(procedure.start_address, procedure_address);
        assert_eq!(procedure.size, 0x40D);
    }

    /// Test if location of invocation addresses and file names can be traced back to source
    #[test]
    pub fn test_get_source_location() {
        let file_content = &test_common::load_test_binary_as_bytes(
            "hello_world",
            &test_common::TestSubjectType::Debug,
        ).unwrap();

        let parser = get_parser().expect("Could not parse test file contents");
        let context = parser.parse(file_content);

        let call_graph: CallGraph<(), (), ()> = X86CallGraphBuilder {
            invocation_finders: vec![
                Box::new(StaticCallInvocationFinder),
                Box::new(LEABasedDynamicInvocationFinder::default()),
            ],
        }.build_call_graph(&context);

        let main_index = call_graph
            .graph
            .node_indices()
            .find(|index| call_graph.graph[*index].borrow().name == "main")
            .unwrap();

        let main_procedure = call_graph.graph[main_index].borrow();

        assert!(
            main_procedure
                .location
                .as_ref()
                .unwrap()
                .file
                .ends_with("hello_world/src/main.rs")
        );
        assert_eq!(main_procedure.location.as_ref().unwrap().line, 9);
    }
}
